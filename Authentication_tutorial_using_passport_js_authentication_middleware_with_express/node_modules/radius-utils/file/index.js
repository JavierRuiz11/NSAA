const { spawn } = require("child_process");
const { promises: fs } = require("fs");
const fsextra = require("fs-extra");
const path = require("path");
const rmfr = require("rmfr");

const file = {};

file.checkDirectory = async (path) => fs.state(path);
file.clearDirectory = async (path) => fs.emptyDir(path);
file.createDirectory = async (path) => fs.mkdir(path);
file.fileExists = async (path) => fs.access(path);
file.copy = async (path, destination) => fsextra.copy(path, destination);
file.rename = async (path, destination) => fs.rename(path, destination);
file.delete = async (path) => rmfr(path);

const isInstaller = (file) =>
  file.match(/(exe|dmg|pkg)/g) && !file.match(/(blockmap)/g);

file.getInstallers = async (path) => {
  const files = await fs.readdir(path);
  return files
    .filter((file) => isInstaller(file))
    .map((file) => `${path}/${file}`);
};

file.copyFiles = async (files, destination) => {
  await Promise.all(
    files.map(async (file) => {
      const fn = file.replace(/^.*[\\/]/, "");
      await fsextra.copy(file, `${destination}${fn}`);
    })
  );
};

file.getFilesAndDirectories = (dir) => {
  let files = [];
  let directories = [];
  const readDir = (currentPath) => {
    let children = fs.readdirSync(currentPath);
    children.forEach((childPath) => {
      let child = path.join(currentPath, childPath);
      if (childPath !== ".DS_Store") {
        if (fs.statSync(child).isFile()) {
          files.push(child.replace(dir, ""));
        } else if (fs.statSync(child).isDirectory()) {
          directories.push(child.replace(dir, ""));
          readDir(child);
        }
      }
    });
  };

  readDir(dir);
  return { files, directories };
};

file.zip = async (source, destination) =>
  new Promise((resolve, reject) => {
    const zipSource = source.replace(/ \//g, "\n");
    const zipName = `${destination}.zip`;
    const cmd = `ditto -ck --rsrc --sequesterRsrc '${zipSource}' '${zipName}'`;
    const proc = spawn(cmd, { shell: true });

    proc.on("exit", (code) => {
      if (code !== 0) reject(code);
      else resolve(zipName);
    });
  });

file.saveJSON = async (path, json) =>
  fs.writeFile(path, JSON.stringify(json, undefined, 2));

module.exports = file;
